Graph_BFS:
---------

Examples:

				.0	
			.	  .  .
		2.		3		.1
		.
	4.


Input: adj[][] = [[2, 3, 1], [0], [0, 4], [0], [2]]

Output: [0, 2, 3, 1, 4]
Explanation: Starting from 0, the BFS traversal will follow these steps: 
Visit 0 → Output: 0 
Visit 2 (first neighbor of 0) → Output: 0, 2 
Visit 3 (next neighbor of 0) → Output: 0, 2, 3 
Visit 1 (next neighbor of 0) → Output: 0, 2, 3, 1
Visit 4 (neighbor of 2) → Final Output: 0, 2, 3, 1, 4


============

	BFS algo starts from a source node and explores the graph level by level.
	First, it visits all nodes directly adjacent to the source.Then ,it moves on to visit the adj nodes
	of those nodes.this process repeates untill all reacable nodes are visited.
	
	
==============

Steps:

we are using queue data structure(it always contains starting node) and visited array.
Will start with starting node and mark it as visited. push this node to queue.
for every iteration, we pop out the node v from queue and store into our result list.
all unvisted adjacent nodes from v are visited next and pushed to queue.
repeate these steps until queue is empty.
	
==========

class Solution {
    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {
        int size=adj.size();
        boolean[] visited=new boolean[size];
        ArrayList<Integer> res=new ArrayList<>();
        int src=0;
        Queue<Integer> q=new LinkedList<>();
        visited[src]=true;
        q.add(src);
        
        while(!q.isEmpty())
        {
            int curr=q.poll();
            res.add(curr);
            
            //visit all the unvisted neighbours of current node
            for(int x:adj.get(curr))
            {
                if(!visited[x])
                {
                    visited[x]=true;
                    q.add(x);
                }
            }
        }
        return res;
    }
}


=======

Time Complexity: O(V + E), BFS explores all the vertices and edges in the graph. It visits every vertex and edge only once.
Auxiliary Space: O(V), Using a queue to keep track of the vertices that need to be visited.

