Graph:DFS:
----------
	Depth First Search starts from a given source vertex and explores one path as deeply as possible.When it reaches a vertex with no unvisited neighbors,
it backtracks to the previous vertex to explore other unvisited paths.This continues untill all vertices from the source are visited.
In graph,there might be loops.So we can use an extra visited array to make sure that we do not process a vertex again.

steps:

1.pick random node from graph.
2.create visited array and mark that node as visited once its traversed.
3.print that node.
4.get neighbour nodes and perfrom above steps recursively deeply if node is unvisited.

...	1------------2
.	. .		    .
.	.	 .		.
.	.		.	.
.	.		  .	.
.	3			4
.
5

(1,2)
(1,3)
(1,4)
(2,4)
(3,4)
(1,5)

============================


			f(2)

		f(4)		f(1)

	f(1)

f(3)	f(5)

=========

class Solution {
    public ArrayList<Integer> dfs(ArrayList<ArrayList<Integer>> adj) {
        boolean[] visited=new boolean[adj.size()];
        ArrayList<Integer> res=new ArrayList<>();
        dfsRec(adj,visited,1,res);
        return res;
    }
    
    static void dfsRec(ArrayList<ArrayList<Integer>> adj,boolean[] visited,int s,ArrayList<Integer> res)
    {
        visited[s]=true;
        res.add(s);
        //Recursively visit all adjacent vertices that are not visited yet
        for(int i:adj.get(s))
        {
            if(!visited[i])
            {
                dfsRec(adj,visited,i,res);
            }
        }
    }
}


=============

Time complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph.
Auxiliary Space: O(V + E), since an extra visited array of size V is required, And stack size for recursive calls to dfsRec function.
