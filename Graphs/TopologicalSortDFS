Topological Sorting
-------------------

Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uâ†’v, vertex u comes before v in the ordering. 
There may be several topological orderings for a graph.

Note: Topological Sorting for a graph is not possible if the graph is not a DAG.



==========================================
package com.graph;

import java.util.ArrayList;
import java.util.Stack;

/*
 * 
 * Time Complexity: O(V + E),This is because in a topological sort using DFS, each vertex is visited exactly once, 
 * and each directed edge is explored exactly once during the DFS traversal. The cost of visiting all vertices is O(V) and the
 * cost of exploring all edges is O(E). Since both happen sequentially and not nested, the total time complexity is O(V + E). 
 * For example, if V = 6 and E = 6, the DFS will make exactly 6 vertex visits and 6 edge explorations, 
 * leading to a total of O(6 + 6) = O(12), which simplifies to O(V + E).

  Space Complexity: O(V + E),The space complexity comes from three parts: the adjacency list (which stores all vertices and edges,
  taking O(V + E) space), the visited array (O(V) space), and the recursion stack (O(V) in the worst case for a DFS if the graph
  is like a chain). The stack used to store the topological order will also take O(V) space. 
  Therefore, the dominant space usage is O(V + E). For example, if V = 6 and E = 6, the adjacency list will store all 6 vertices
  and 6 edges (O(12) space), the visited array takes O(6), and the recursion stack may take up to O(6) in the worst case, 
  keeping the total within O(V + E).
 */
public class TopoSortDFS {
	public static void main(String[] args) {
		// number of vertices
		int v = 6;
		// Create a adjacency list for graph
		ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
		for (int i = 0; i < v; i++) {
			adj.add(new ArrayList<Integer>());
		}
		System.out.println(adj);
		adj.get(5).add(0);
		adj.get(5).add(2);
		adj.get(4).add(0);
		adj.get(4).add(1);
		adj.get(2).add(3);
		adj.get(3).add(1);
		System.out.println(adj);

		ArrayList<Integer> res = topoSort(adj, v);
		// print the result
		System.out.println("Topological sort:");
		for (int node : res) {
			System.out.print(node + " ");
		}

	}

	public static ArrayList<Integer> topoSort(ArrayList<ArrayList<Integer>> adj, int v) {
		// crate a visited array to mark visited vertices
		int[] vis = new int[v];
		// create a stack to store vertices in finising order
		Stack<Integer> st = new Stack<>();
		// perfrom DFS from each unvisited vertex
		for (int i = 0; i < v; i++) {
			if (vis[i] == 0) {
				dfs(i, adj, vis, st);
			}
		}
		// create ans list
		ArrayList<Integer> ans = new ArrayList<>();
		while (!st.isEmpty()) {
			ans.add(st.pop());
		}
		// return ans
		return ans;
	}

	public static void dfs(int node, ArrayList<ArrayList<Integer>> adj, int vis[], Stack<Integer> st) {
		// mark the current node as visited
		vis[node] = 1;

		// explore all neighbors of current node
		for (int it : adj.get(node)) {
			// if neighbor is not visited , recursively perfrom DFS
			if (vis[it] == 0) {
				dfs(it, adj, vis, st);
			}
		}
		// after visiting all neighbors, push this node into stack
		st.push(node);
	}
}
