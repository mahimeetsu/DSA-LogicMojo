
bruteforce:

/*
class Node {
    int data;
    Node next;
    Node bottom;

    Node(int x) {
        data = x;
        next = null;
        bottom = null;
    }
}
*/
class Solution {
    public Node flatten(Node root) {
        List<Integer> list=new ArrayList<>();
        while(root!=null)
        {
            //traverse through the child nodes of each head node
            Node temp=root;
            while(temp!=null)
            {
                //store each child nodes data into list
                list.add(temp.data);
                //move to next child node
                temp=temp.bottom;
            }
            //once all child nodes are completed, then move to next root node
            root=root.next;
         }
            //sort arraylist in ascending order
            Collections.sort(list);
            //convefrt sorted arraylist back to linkedlist
            return convertArrayListToLinkedList(list);
            }
    
    public Node convertArrayListToLinkedList(List<Integer> list)
    {
        //create a dummy node to serve as a head node
        Node dummyNode=new Node(-1);
        Node temp=dummyNode;
        
        //iterate list and create nodes with elements
        for(int i=0;i<list.size();i++)
        {
            temp.bottom=new Node(list.get(i));
            //move temp pointer to the newly created node
            temp=temp.bottom;
        }
        
        //return the linkedlist starting from the next of the dummy node
        return dummyNode.bottom;
    }
    
}


Time Complexity: O(N*M) + O(N*M log(N*M)) + O(N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.

O(N*M) as we traverse through all the elements, iterating through ‘N’ nodes along the next pointer and ‘M’ nodes along the child pointer.
O(N*M log(N*M)) as we sort the array containing N*M (total) elements.
O(N*M) as we reconstruct the linked list from the sorted array by iterating over the N*M elements of the array.
Space Complexity : O(N*M) + O(N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.

O(N*M) for storing all the elements in an additional array for sorting.
O(N*M) to reconstruct the linked list from the array after sorting



======================================



Optmial:

/*
class Node {
    int data;
    Node next;
    Node bottom;

    Node(int x) {
        data = x;
        next = null;
        bottom = null;
    }
}
*/
class Solution {
    public Node flatten(Node root) {
        //base case: if head is null, if there is no next node.then return head as it is
        if(root==null||root.next==null)
            return root;
        //if the base case not met, then call same function recursively . this function continues until it reaches base case 
        Node mergedHead=flatten(root.next);
        //the above recursive fun will return the merged head of the flattened linked list.this mergedHead will now 
        //merged with current head
        root=merge(mergedHead,root);
        return root;
    }
    
    public Node merge(Node list1,Node list2)
    {
        Node dummyNode=new Node(-1);
        Node result=dummyNode;
        
        while(list1!=null&&list2!=null)
        {
            if(list1.data<list2.data)
            {
                result.bottom=list1;
                result=list1;
                list1=list1.bottom;
            }
            else
            {
                result.bottom=list2;
                result=list2;
                list2=list2.bottom;
            }
            result.next=null;
        }
        
        if(list1!=null)
        {
            result.bottom=list1;
        }
        else
        {
            result.bottom=list2;
        }
        //break the last nodes link to prevent cycle
        if(dummyNode.bottom!=null)
        {
            dummyNode.bottom.next=null;
        }
        
        return dummyNode.bottom;
    }
    
}


Time Complexity: O( N*(2M) ) ~ O(2 N*M)where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointers.

The merge operation in each recursive call takes time complexity proportional to the length of the linked lists being merged as they have to iterate over the entire lists. Since the vertical depth of the linked lists is assume to be M, the time complexity for a single merge operation is proportional to O(2*M).
This operation operation is performed N number of times (to each and every node along the next pointer list) hence the resultant time complexity becomes: O(N* 2M).

Space Complexity : O(1) as this algorithm uses no external space or additional data structures to store values. But a recursive stack uses O(N) space to build the recursive calls for each node along the next pointer list.
